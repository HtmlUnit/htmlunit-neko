/*
 * Copyright 2002-2009 Andy Clark, Marc Guillemot
 * Copyright 2017-2023 Ronald Brill
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.htmlunit.cyberneko;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * This class is an input stream filter that skips the first
 * three bytes read if they match the UTF-8 byte order mark,
 * 0xEFBBBF. The UTF-8 BOM is most often generated by Windows&reg;
 * tools.
 *
 * @author Andy Clark
 */
public class UTF8BOMSkipper extends FilterInputStream {

    /** Start of reading. */
    private boolean start_ = true;

    /** Byte offset. */
    private int offset_;

    /** First three bytes. */
    private int[] first3Bytes_;

    /** Constructs a UTF-8 BOM skipper. */
    public UTF8BOMSkipper(final InputStream stream) {
        super(stream);
    }

    /** Returns the next byte. */
    @Override
    public int read() throws IOException {
        // read first three bytes in order to skip UTF-8 BOM, if present
        if (start_) {
            start_ = false;
            final int b1 = super.read();
            final int b2 = super.read();
            final int b3 = super.read();
            if (b1 != 0xEF || b2 != 0xBB || b3 != 0xBF) {
                first3Bytes_ = new int[3];
                first3Bytes_[0] = b1;
                first3Bytes_[1] = b2;
                first3Bytes_[2] = b3;
            }
        }

        // return read bytes
        if (first3Bytes_ != null) {
            final int b = first3Bytes_[offset_++];
            if (offset_ == first3Bytes_.length) {
                first3Bytes_ = null;
            }
            return b;
        }

        // return next char
        return super.read();
    }

    /** Reads bytes into specified buffer and returns total bytes read. */
    @Override
    public int read(final byte[] buffer, final int offset, final int length) throws IOException {

        if (start_ || first3Bytes_ != null) {
            for (int i = 0; i < length; i++) {
                final int b = this.read();
                if (b == -1) {
                    return i > 0 ? i : -1;
                }
                buffer[offset + i] = (byte) b;
            }
            return length;
        }

        return super.read(buffer, offset, length);
    }

    /** Mark is not supported for this input stream. */
    @Override
    public boolean markSupported() {
        return false;
    }

    /** Returns the number of bytes available. */
    @Override
    public int available() throws IOException {
        if (first3Bytes_ != null) {
            return first3Bytes_.length - offset_;
        }
        return super.available();
    }
}
